ext.setupJava8Test = (Map data) -> {
    def taskName = 'java8Test'
    def configName = "${taskName}Implementation"
    sourceSets.create(taskName) {
        java {
            srcDir file("src/integration/${taskName}")
            compileClasspath += sourceSets.main.output + sourceSets.test.output
            runtimeClasspath += sourceSets.main.output + sourceSets.test.output
        }
    }
    tasks.getByName("compile${taskName.capitalize()}Java") {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }

    def sourceSet = sourceSets.getByName(taskName)
    configurations.getByName(configName).extendsFrom configurations.testFixturesApi
    dependencies.add(configName, [group: data.group, name: data.name, version: data.version])
    tasks.register(taskName, Test) {
        useJUnitPlatform()
        group = 'integration'
        testClassesDirs = sourceSet.output.classesDirs
        classpath = sourceSet.runtimeClasspath
        javaLauncher = javaToolchains.launcherFor {
            languageVersion = JavaLanguageVersion.of(8)
        }
    }
    tasks.check.dependsOn taskName
}

/**
 * Each provider gets SourceSet with Test task.
 * Each additional version of provider reuses created SourceSet and creates Configuration and Test task for itself.
 */
ext.setupProviderTest = (Map data) -> {
    def taskName = "${data.id}Test"
    def configName = "${taskName}Implementation"
    def rootDir = file("src/integration/${taskName}")
    if (!rootDir.exists()) {
        throw new GradleException("Missing JSON provider interation test suite for ${taskName}")
    }
    sourceSets.create(taskName) {
        java {
            srcDir rootDir
            compileClasspath += sourceSets.main.output + sourceSets.test.output
            runtimeClasspath += sourceSets.main.output + sourceSets.test.output
        }
    }
    def sourceSet = sourceSets.getByName(taskName)
    configurations.getByName(configName).extendsFrom configurations.testImplementation, configurations.formatImplementation
    dependencies.add(configName, [group: data.group, name: data.name, version: data.version])
    tasks.register(taskName, Test) {
        useJUnitPlatform()
        jvmArgs("-XX:+EnableDynamicAgentLoading")
        group = 'integration'
        testClassesDirs = sourceSet.output.classesDirs
        classpath = sourceSet.runtimeClasspath
    }
    tasks.check.dependsOn taskName

    (data.additionalVersions as List<String>).forEach { version ->
        def additionalTaskName = "${data.id}${version.replace('.', '_')}Test"
        def additionalConfigName = "${additionalTaskName}Implementation"
        configurations.create(additionalConfigName)
        configurations.getByName(additionalConfigName).extendsFrom configurations.testImplementation, configurations.formatImplementation
        dependencies.add(additionalConfigName, [group: data.group, name: data.name, version: version])
        tasks.register(additionalTaskName, Test) {
            useJUnitPlatform()
            jvmArgs("-XX:+EnableDynamicAgentLoading")
            group = 'integration'
            environment 'PROVIDER_VERSION', version
            systemProperty 'junit.jupiter.displayname.generator.default', 'dev.harrel.jsonschema.util.VersionAwareNameGenerator'
            testClassesDirs = sourceSet.output.classesDirs
            classpath = configurations.getByName(additionalConfigName).getIncoming().getFiles() + sourceSet.output + sourceSets.test.output + sourceSets.main.output
        }
        tasks.check.dependsOn additionalTaskName
    }
}

/* For GH actions */
tasks.register('integrationTasksArray') {
    def taskNames = tasks.findAll { it.group == 'integration' }.name
    print groovy.json.JsonOutput.toJson(taskNames)
}